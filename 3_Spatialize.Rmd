---
title: "R Notebook"
output: html_notebook
---

# Intro

inputs: (1) resp (in intermediate folder) (2) pred (in intermediate folder)
workflow: the marvid sections (aka sample info) object is generated here
outputs: v

# Libraries
```{r}
library(dplyr)
```


# Inputs
```{r}
resp <- read.csv(file.path(savepath, paste(vme,"resp.csv", collapse=" ")))

load(file.path(savepath,"1_Predictors_out.RData"))

```

## Aggregate to whole video line and calculate sd
```{r}
respw <- left_join(resp, sample_info) %>% group_by(video.line) %>%
  summarize(mean_rich = mean(tot_rich), mean_dens = mean(tot_dens), sd_dens = sd(tot_dens))
head(respw)
```


# Libraries
```{r}
library(rgdal)
library(dplyr)
library(raster)
library(qdapTools)
library(RPostgreSQL)
```

# Get coordinates of samples
```{python}
import requests

API_URL = "http://marvid-staging.hi.no:8092/query/video_lines"
OUTPUL_FILEPATH = "C:\\Users\\genoveva\\Downloads\\marvid_sections.csv"
DELIMITER = ","
CSV_HEADER = DELIMITER.join(["video line", "section", "mean latitude", "mean longitude"])

api_response = requests.get(API_URL).json() 
output_strings = [CSV_HEADER] 
for vl_number in sorted(api_response.keys()):
    vl = api_response[vl_number]
    for section in sorted(vl["sections"]):
        mean_lat = str(vl["sections"][section]["mean_lat"])
        mean_lon = str(vl["sections"][section]["mean_lon"])
        output_strings.append(DELIMITER.join([vl_number, section, mean_lat, mean_lon]))

with open(OUTPUL_FILEPATH, "w") as output_file:
    output_file.write("\n".join(output_strings))n
```


# Make sample info
```{r}
# sample_info <- read.csv(file.path(Data, "marvid_sections.csv"))
# sample_info <- sample_info %>% makesampid
```

# Make spatial object
```{r}
resp_spat1 <- resp %>% mutate(mean_long=as.numeric(pull(
                                dplyr::filter(data.frame(lookup(SampID,select(sample_info, c(SampID, mean.longitude)), missing = NULL)), 
                                                      !duplicated(data.frame(qdapTools::lookup(SampID,select(sample_info, c(SampID, mean.longitude)), missing = NULL)))
                                                       ))),
                             mean_lat=as.numeric(pull(
                               dplyr::filter(data.frame(lookup(SampID,select(sample_info, c(SampID, mean.latitude)), missing = NULL)), 
                                                      !duplicated(data.frame(qdapTools::lookup(SampID,select(sample_info, c(SampID, mean.latitude)), missing = NULL)))
                                                       )))) %>%
            filter(!is.na(mean_long))
resp_spat <- SpatialPointsDataFrame(select(resp_spat1, c(mean_long, mean_lat)), select(resp_spat1, c(SampID,tot_rich, tot_dens, vmeind_density)))  
                      #%>% utmize

writeOGR(resp_spat, savepath, paste("resp_spat", vme), driver = "ESRI Shapefile", overwrite_layer = TRUE)

# make resp have the same number of rows as resp_spat:

resp <- resp %>% filter(SampID%in%resp_spat@data$SampID)
```

# Get coordinates of video lines
```{r}
library(RPostgreSQL)
library(rgdal)

postgres_driver <- dbDriver("PostgreSQL")
postgres_conn <- dbConnect(postgres_driver,
                           dbname = "marbunn",
                           host = "postgres.hi.no",
                           port = 5432,
                           user = "marbunn_read",
                           password = "Ecac7adgb!")
tab_station <- dbGetQuery(postgres_conn, "select * from tab_station")
tab_station <- tab_station[which(tab_station$equipment==2),]

```

# Make spatial object, video line level
```{r}

resp_spat1 <- respw %>% mutate(mean_long=as.numeric(pull(
  dplyr::filter(data.frame(lookup(video.line,select(tab_station, c(sample_no, lon_mid_dec)), missing = NULL))))),
  mean_lat=as.numeric(pull(
    dplyr::filter(data.frame(lookup(video.line,select(tab_station, c(sample_no, lat_mid_dec)), missing = NULL)))))) %>%
  dplyr::filter(!is.na(mean_long)) %>% rename(vmeind_density = mean_dens)

coords <- coordinates(select(resp_spat1, c(mean_long, mean_lat)))

resp_spat <- SpatialPointsDataFrame(coords, dplyr::select(resp_spat1, c(video.line,mean_rich, vmeind_density, sd_dens))) %>%
                       utmize

writeOGR(resp_spat, savepath, paste("resp_spat", vme), driver = "ESRI Shapefile", overwrite_layer = TRUE)

# make resp have the same number of rows as resp_spat:

respw <- respw %>% filter(video.line%in%resp_spat@data$video.line)
```


# Extract environmental data to points
```{r}
e <- raster::extract(pred, resp_spat, sp=TRUE)
v <- left_join(select(resp, SampID),data.frame(e), by="SampID")
# generate random data if needed
v
```

# Save outputs
```{r}
rm(resp_spat1)
write.csv(v, file.path(savepath, "v.csv"), row.names = FALSE)
```
