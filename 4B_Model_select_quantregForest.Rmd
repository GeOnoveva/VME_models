---
title: "R Notebook"
output: html_notebook
---

inputs: v, resp_spat (whole video line level), pred

# Libraries etc
```{r}
library(quantregForest)
library(tidyverse)
library(rgdal)
library(caret)
library(spm)

quantiles = c((1-.682)/2, 0.5, 1-(1-.682)/2)
## color legend:
leg = c("#0000ff", "#0028d7", "#0050af", "#007986", "#00a15e", "#00ca35", 
        "#00f20d", "#1aff00", "#43ff00", "#6bff00", "#94ff00", "#bcff00", 
        "#e5ff00", "#fff200", "#ffca00", "#ffa100", "#ff7900", "#ff5000", "#ff2800", "#ff0000")
```

# Inputs
```{r}
# get v (read)
v <- read.csv(file.path(savepath, "v.csv"))
# str(v)

v <- v %>% 
      mutate_at(vars(  landscape, sedclass, seddan, sedmil    ), factor)
```

# More inputs: resp spat at station level
```{r}
resp_spat_vl <- readRDS(file.path(savepath, "resp_Spat_vl.rds"))
```

# More inputs: pred
comes with a bunch of other objects because loading whole workspace
```{r}
#load(file.path(savepath,"1_Predictors_out.RData"))
pred.pix <- readRDS(file.path(savepath,"pred.rds"))
```

# Using the quantregForest library
This needs v_train and v_test, which are generated in Noebook 4
```{r}
# train
Ytrain = v_train %>%
  dplyr::select(vmeind_density) %>% pull
Xtrain <- v_train %>% dplyr::select(6:dim(v_train)[2])
  #%>% rescl5_260
qrf <- quantregForest(x=Xtrain, y=Ytrain)

Xtest = v_test %>% dplyr::select(6:dim(v_test)[2])

predicted <- predict(qrf, Xtest, what=mean)
observed <- v_test %>%
  dplyr::select(vmeind_density)
idx <- which(is.na(pull(data.frame(unlist(predicted)))))
vecv <- vecv(pull(observed)[-idx],pull(data.frame(unlist(predicted)))[-idx]) # variance explained by cross-validation, conservative estimate to report
vecv
```
# Another approach (using ranger)

```{r}
library(ranger)
qrf2<-ranger(fmla0, v_train, mtry=5,  min.node.size=2, sample.fraction=0.9930754, num.trees=500, # these parameters need to have been fined-tuned on a previous step
                   importance="impurity", seed=1, quantreg= TRUE)
qrf2
```

```{r}
xl <- as.list(ranger::importance(qrf2))
print(t(data.frame(xl[order(unlist(xl), decreasing=TRUE)[1:10]])))
```

```{r}
vme.qrf2 <- predict(qrf2, cbind(
  #swiss.dist0@data, 
  v_test), 
                     type="quantiles", quantiles=quantiles)$predictions
## now more computational...
v_test$vme.qrf2pr = vme.qrf2[,2]
## s.d. of the prediction error:
v_test$vme.qrf2var = (vme.qrf2[,3]-vme.qrf2[,1])/2
head(v_test)
```

```{r}
predicted <- v_test$vme.qrf2pr
observed <- v_test %>%
  dplyr::select(vmeind_density)

vecv <- vecv(pull(observed),pull(data.frame(unlist(predicted)))) # variance explained by cross-validation, conservative estimate to report
vecv

```
# Whole mapping area

```{r}
resp.dist0 <-buffer.dist(resp_spat_vl["vmeind_density"], 
                                 pred.pix[1], as.factor(1:nrow(resp_spat_vl))) 
## takes 1+ mins!
ov.resp = over(resp_spat["vmeind_density"], resp.dist0)
sw.dn0 <- paste(names(resp.dist0), collapse="+")
fmla01 <- as.formula(paste("vmeind_density ~ ", 
                           sw.dn0, 
                           " + ",
                           xxxxxxxxxxxxxx)) # names of pred@data with +'s in between
fmla01
ov.resp <- over(resp_spat["vmeind_density"], pred.pix[1:2])
sw.rm = do.call(cbind, list(resp_spat@data["vmeind_density"], ov.resp
                            , ov.resp
                            ))
```

# fine tune RF parameters
```{r}
control <- trainControl(method="repeatedcv", number=10, repeats=3, search="grid")
set.seed(1)
tunegrid <- expand.grid(.mtry=c(1:30))
rf_gridsearch <- train(fmla0, data=v, method="qrf", metric="Rsquared", tuneGrid=tunegrid, trControl=control)
print(rf_gridsearch)
plot(rf_gridsearch)
```

# select variables
```{r}

```

# train final model
```{r}
m1 <- ranger(fmla01, sw.rm[complete.cases(sw.rm),], mtry=27, #mtry was 27 
                  min.node.size=2, sample.fraction=0.9930754, 
                  num.trees=150, importance = "impurity", seed=1, quantreg=TRUE)
m1
```

# predict
```{r}
vme.rfd1 <- predict(m1, cbind(
  resp.dist0@data, 
  pred.pix@data), 
                     type="quantiles", quantiles=quantiles)$predictions
## now more computational...
pred.pix$vme_dens = vme.rfd1[,2]
## s.d. of the prediction error:
pred.pix$vme_dens_var = (vme.rfd1[,3]-vme.rfd1[,1])/2
str(pred.pix@data)
```

# visualize
```{r qrf-sic97-maps, echo=FALSE, fig.width=9, fig.cap="Predictions and prediction errors for the SIC97 data set."}
par(mfrow=c(1,2), oma=c(0,0,0,0.5), mar=c(0,0,1.5,1))
plot(raster(pred.pix["vme_dens"]), col=leg, 
     main="Random Forest (RF)", axes=FALSE, box=FALSE)
points(resp_spat, pch="+")
plot(raster(pred.pix["vme_dens_var"]), col=rev(bpy.colors()), 
     main="Random Forest (RF) prediction error", axes=FALSE, box=FALSE)
points(resp_spat, pch="+")
```

# save outputs
```{r}
writeGDAL(swiss1km["rainfall_rfd1"], fname = "../RF_vs_kriging/results/rainfall/pred_rainfall_RFsp.tif", options = c("COMPRESS=DEFLATE"))
writeGDAL(swiss1km["rainfall_rfd1_var"], fname = "../RF_vs_kriging/results/rainfall/pred.var_rainfall_RFsp.tif", options = c("COMPRESS=DEFLATE"))

```

